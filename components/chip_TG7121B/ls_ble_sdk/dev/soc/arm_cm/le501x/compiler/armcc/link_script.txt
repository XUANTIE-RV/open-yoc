#! armcc -E

#define FLASH_BASE 0x18000000
#define FLASH_BASE_USER 0x18005000
#define FLASH_SIZE 0x40000
#define FLASH_END (FLASH_BASE + FLASH_SIZE)
#define RAM_BASE 0
#define RAM_SIZE 0xc000
#define RAM_END (RAM_BASE + RAM_SIZE)
#define RESET_RETAIN_VALID_START_ADDR 0x6EA8
#define RESET_RETAIN_VALID_ENMD_ADDR 0xB800

LR_FLASH FLASH_BASE_USER FLASH_SIZE{
    VECTOR_CODE RAM_BASE{
        *(RESET, +First)
    }
    
    RAM_DATA_CODE +0 RAM_SIZE{
        *(+RW)
        *(.xip_banned)
		*(:gdef:__aeabi_memcpy)
    }
    
    FLASH_CODE FLASH_BASE_USER+ImageLength(RAM_DATA_CODE)+ImageLength(VECTOR_CODE) ALIGN 0x4{
        *(InRoot$$Sections)
        *(+RO)
    }
    ScatterAssert(ImageLimit(FLASH_CODE) <= FLASH_END)
    
    BSS ImageLimit(RAM_DATA_CODE) ALIGN 0x4
    {
        *(SECTION_RTT)
        *(+ZI)
    }
    HEAP +0 UNINIT
    {
        *(HEAP)
    } 
    ;ScatterAssert(ImageLimit(HEAP)>=RESET_RETAIN_VALID_START_ADDR)
    RESET_RETAIN_DATA (ImageLimit(HEAP) < RESET_RETAIN_VALID_START_ADDR ? RESET_RETAIN_VALID_START_ADDR : ImageLimit(HEAP)) UNINIT EMPTY 0x8
    {
        
    }
    ScatterAssert(ImageLimit(RESET_RETAIN_DATA)<=RESET_RETAIN_VALID_ENMD_ADDR)
    RW_IRAM6 0x0000A000 UNINIT 0x2000 { 
        *(DMARAM)
    }
    STACK +0 UNINIT
    {
        *(STACK)
    } 
    ScatterAssert(ImageLimit(STACK)<=RAM_END)
}
